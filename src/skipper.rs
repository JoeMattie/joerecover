use std::collections::HashSet;
use std::fs;
use std::io::{self, BufRead, BufReader};
use std::path::Path;
use joerecover::{load_bip39_dictionary, process_line};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Load BIP39 dictionary
    let dictionary = load_bip39_dictionary("bip39_wordlist_en.txt").unwrap_or_else(|_| {
        HashSet::new()
    });
    
    // Load all skip token sets from the skip folder
    let skip_word_sets = load_skip_folder(&dictionary)?;
    
    // Read from stdin and filter
    let stdin = io::stdin();
    let reader = BufReader::new(stdin.lock());
    
    for line in reader.lines() {
        let line = line?;
        let line = line.trim();
        
        if line.is_empty() {
            continue;
        }
        
        // Check if this permutation could be generated by any skip token set
        if !is_permutation_in_skip_sets(&line, &skip_word_sets) {
            println!("{}", line);
        }
    }
    
    Ok(())
}

/// Load all .txt files from the skip folder and parse them into word sets
fn load_skip_folder(dictionary: &HashSet<String>) -> Result<Vec<Vec<Vec<String>>>, Box<dyn std::error::Error>> {
    let skip_dir = Path::new("skip");
    let mut all_skip_sets = Vec::new();
    
    if !skip_dir.exists() {
        // No skip folder exists, so nothing to skip
        return Ok(all_skip_sets);
    }
    
    // Read all .txt files in the skip directory
    for entry in fs::read_dir(skip_dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if path.extension().and_then(|s| s.to_str()) == Some("txt") {
            match load_token_file(&path, dictionary) {
                Ok(word_sets) => {
                    if !word_sets.is_empty() {
                        all_skip_sets.push(word_sets);
                    }
                }
                Err(e) => {
                    eprintln!("Warning: Failed to load skip file '{}': {}", path.display(), e);
                }
            }
        }
    }
    
    Ok(all_skip_sets)
}

/// Load a single token file and return its word sets
fn load_token_file(path: &Path, dictionary: &HashSet<String>) -> Result<Vec<Vec<String>>, Box<dyn std::error::Error>> {
    let content = fs::read_to_string(path)?;
    let lines: Vec<&str> = content.lines().collect();
    
    let mut word_sets = Vec::new();
    
    for line in lines {
        if line.trim().is_empty() {
            continue;
        }
        
        let expanded_words = process_line(line, dictionary)?;
        if !expanded_words.is_empty() {
            word_sets.push(expanded_words);
        }
    }
    
    Ok(word_sets)
}

/// Check if a permutation line could be generated by any of the skip word sets
fn is_permutation_in_skip_sets(permutation: &str, skip_sets: &[Vec<Vec<String>>]) -> bool {
    let words: Vec<&str> = permutation.split_whitespace().collect();
    
    for word_sets in skip_sets {
        if could_generate_permutation(&words, word_sets) {
            return true;
        }
    }
    
    false
}

/// Check if a specific permutation could be generated from a set of word sets
fn could_generate_permutation(permutation_words: &[&str], word_sets: &[Vec<String>]) -> bool {
    // Must have the same number of words as word sets
    if permutation_words.len() != word_sets.len() {
        return false;
    }
    
    // Check if each word in the permutation could come from the corresponding word set
    for (i, word) in permutation_words.iter().enumerate() {
        if !word_sets[i].contains(&word.to_string()) {
            return false;
        }
    }
    
    true
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_could_generate_permutation() {
        let word_sets = vec![
            vec!["cat".to_string(), "dog".to_string()],
            vec!["red".to_string(), "blue".to_string()],
        ];
        
        // Valid permutations
        assert!(could_generate_permutation(&["cat", "red"], &word_sets));
        assert!(could_generate_permutation(&["dog", "blue"], &word_sets));
        assert!(could_generate_permutation(&["cat", "blue"], &word_sets));
        
        // Invalid permutations
        assert!(!could_generate_permutation(&["bird", "red"], &word_sets)); // bird not in first set
        assert!(!could_generate_permutation(&["cat", "green"], &word_sets)); // green not in second set
        assert!(!could_generate_permutation(&["cat"], &word_sets)); // wrong number of words
        assert!(!could_generate_permutation(&["cat", "red", "extra"], &word_sets)); // too many words
    }
}